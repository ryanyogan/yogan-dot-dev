---
title: I still love Prisma and I'm not ashamed to admit it
description: Here's my honest, slightly unhinged take on why it remains my go-to in 2025, with my (weird) comparisons to the alternatives you're probably considering.
published: 2025-01-01
featured: true
---

# {frontmatter.title}

Welcome to my completely unfiltered rant on why I'm still using **Prisma** in 2025 despite the JavaScript ecosystem trying to make me feel like I'm using Internet Explorer in 2015. If you're like me, you just want to build cool shit without wrestling with yet another abstraction layer that'll be abandoned faster than people left Clubhouse.

---

## Prisma: My Happy Rails Revival

First things first: **Prisma gives me the same happy feeling I got from Rails' Active Record**. And let's be honest, much of Rails' success came from Active Record. Remember the joy of writing your first Rails model? Three lines of code and suddenly you're a database wizard!

```ruby
# Rails made this so easy
class User < ApplicationRecord
  has_many :posts
end
```

Prisma hits that same dopamine button:

```prisma
// Look Ma, I'm defining a whole data model!
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  posts Post[]
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  content  String?
  author   User   @relation(fields: [authorId], references: [id])
  authorId Int
}
```

That feeling when your brain just goes "Ah, yes, this makes sense"? That's what Prisma gives me. It's like reconnecting with an old friend who's mellowed out and gotten their life together.

---

## The SQL Paradox: I Know It, But I Don't Always Want to Write It

Let's get something straight: **I love SQL**. I write complex queries for fun sometimes. I add indices to my tables the way some people add hot sauce to their food—liberally and with enthusiasm. I genuinely believe everyone should learn SQL properly. The deeper I go with SQL, the more problems I can elegantly solve.

Take this example where I needed to find users who hadn't logged in for 90 days but had been active before:

```sql
SELECT u.id, u.email, MAX(l.login_date) as last_login
FROM users u
LEFT JOIN logins l ON u.id = l.user_id
GROUP BY u.id
HAVING last_login < (CURRENT_DATE - INTERVAL '90 days')
   AND last_login > (CURRENT_DATE - INTERVAL '180 days');
```

Beautiful, right? I solved that with SQL and felt like a goddamn wizard.

But here's the paradox—sometimes I just want to think in entities. People. Products. Orders. The real things my app is modeling. I don't always want to mentally translate between my domain model and SQL's relational structure just to fetch a damn user profile.

I don't need to think about left joins when I can look at a Prisma schema and understand the entire application at a glance. I want to say "give me this user and their posts" without writing a JOIN statement for the 1000th time:

```typescript
// This is just nicer than writing another JOIN
const userWithPosts = await prisma.user.findUnique({
  where: { id: userId },
  include: { posts: true }
});
```

That's where Prisma fills my cup.

---

## Performance? Please, I'm Building Fun Stuff Here

Let me be crystal clear about something: **performance optimization is the last thing I care about** for my personal projects. I'm not Netflix. I'm not handling millions of requests per second. I'm building fun projects that maybe a few hundred people will use.

When someone starts going on about "Prisma adds 20ms overhead compared to raw SQL," I want to ask them if they've fixed the 12 N+1 queries in their codebase or if they're still loading 5MB of uncompressed JavaScript on their landing page.

A real Twitter rant I saw:

> "Spent 2 weeks optimizing my ORM queries to save 30ms, then realized my app was downloading a 2MB hero image. Reduced that to 200KB and saved 500ms. I am not a smart man."

If you're at Netflix or Stripe, sure, go build your custom database drivers and optimize the hell out of every query. You have teams of engineers dedicated to that stuff. But I'm one person trying to ship a side project, and I'd rather spend that time on features people actually care about.

So for my personal and fun projects, the performance argument is moot. And let's be honest, in most real-world apps, your database queries aren't the bottleneck anyway.

---

## The Types: Oh, The Beautiful Types

Some people hate the autogenerated `@prisma/client`. They think it adds bloat or doesn't fit their workflow. I personally find it magical.

Look at this beautiful type safety:

```typescript
// Prisma knows exactly what a User is
async function getUserProfile(id: number): Promise<User | null> {
  return prisma.user.findUnique({
    where: { id },
    include: { profile: true }
  });
}

const user = await getUserProfile(1);
// TypeScript knows user.profile exists and what properties it has
console.log(user.profile.bio);

// It also catches typos immediately
console.log(user.proflie); // Error: Property 'proflie' does not exist on type 'User'
```

No more runtime errors because you misspelled a property name. No more guessing what fields are available on your models. It's all there, statically typed and ready for autocomplete.

As one Reddit post put it: *"Moving from Mongoose to Prisma was like getting glasses for the first time. 'Wait, this is what code is supposed to look like?'"*

---

## Migrations That Don't Make Me Want to Cry

Have you ever tried to roll your own migrations? It's about as fun as a root canal without anesthesia. Prisma's migration system actually does what I want 95% of the time.

Yes, I'll admit that bumping up the RAM on fly.io for Prisma migrations is a bit annoying. Drizzle will work on that 256MB tier without breaking a sweat. But I've got a workaround - I just hack fly with some swap usage:

```toml
# fly.toml
[mount]
source = "sqlite_data"
destination = "/data"

[[services]]
  internal_port = 3000
  protocol = "tcp"

  [services.swap]
    # The secret sauce for running Prisma migrations on cheap VMs
    size_mb = 512
```

Problem solved. Sure, it's a bit of a hack, but it works. And compared to the mental gymnastics of managing migrations manually, it's a small price to pay.

Here's a taste of life before good migration tools:

```sql
-- migration_01.sql
ALTER TABLE users ADD COLUMN middle_name VARCHAR(100);

-- Don't forget to update this in your ORM models
-- And your TypeScript types
-- And your validation schemas
-- And your API documentation
-- And...oh no, did I run this on production already?
```

With Prisma, I just update my schema:

```prisma
model User {
  id         Int    @id @default(autoincrement())
  firstName  String
  middleName String? // Just add this line
  lastName   String
}
```

Then run `prisma migrate dev` and everything is updated: the database, the TypeScript types, and the client. One command. Beautiful.

---

## Prisma Has Stood the Test of Time

Let's talk about longevity. The JavaScript ecosystem moves faster than a caffeinated squirrel. Remember when everyone was using Backbone.js? Or when Meteor was going to revolutionize web development? How about CoffeeScript?

**Prisma has been around while others have come and gone**, and it's still going strong. I'm not interested in rebuilding my projects every six months because some hot new ORM dropped. I want stability.

A HackerNews comment that resonated with me:

> "I've been using Prisma for 3 years. In that time, I've seen at least 4 'Prisma killers' come and go. Meanwhile, my Prisma code still works exactly as it did, just with more features."

I just want to code. I don't want to spend hours learning some new abstraction that promises to be 10% faster or have a slightly more elegant API. Prisma just works for me, and that consistency is worth its weight in gold.

---

## SQLite + Prisma: The Underrated Power Combo

I love SQLite. It's my go-to database for personal projects. It's simple, reliable, and surprisingly powerful. But SQLite doesn't have some features that other databases have, like native enums.

Prisma lets me pretend I have those features:

```prisma
model User {
  id   Int    @id @default(autoincrement())
  role Role   // This looks like an enum, feels like an enum...
}

enum Role {
  USER
  ADMIN
  MODERATOR
}
```

Behind the scenes, Prisma is just using a string in SQLite, but I get all the type safety and developer experience of an enum. The Prisma team realized I don't want to build my own type validation systems - I just want it to work.

As a bonus, when I eventually need to scale up to Postgres, my schema is already compatible. I don't have to change a single line of code.

---

## Cloudflare D1 Support: The Cherry on Top

And now, Prisma supports Cloudflare D1! For those who don't know, D1 is Cloudflare's distributed SQLite database that runs on their edge network. It's like having a globally distributed database without any of the complexity.

This is huge for edge computing. I can now use Prisma with D1 and get all the benefits of edge deployment without compromising on my developer experience.

```typescript
// Running at the edge with Prisma and D1? Yes please!
import { PrismaClient } from '@prisma/client/d1'

const prisma = new PrismaClient();

export async function onRequest(context) {
  const users = await prisma.user.findMany();
  return new Response(JSON.stringify(users));
}
```

I'm absolutely smitten with this combination. It's like Prisma looked at my wishlist and said "we got you."

---

## The Alternatives: An Honest Assessment That Will Probably Offend Someone

### Drizzle ORM: The Cool New Kid Who Might Break Your Heart

- **Pros:**
  - **Lightweight On Resources:** If you're working at the edge with serverless functions, Drizzle's minimal overhead is legitimately useful. One Reddit thread analyzed memory usage that showed Prisma taking 80MB versus Drizzle's 5MB. For edge functions with 128MB limits, that's huge.
  
  - **SQL Query Builder That Feels Natural:** The SQL it generates is so clean you could almost write it yourself. Emphasis on "almost" because who wants to write raw SQL all day?
  
  - **TypeScript Integration Like Peanut Butter and Jelly:** Their type system is genuinely impressive. One GitHub issue comment: *"Drizzle's type inference found a bug in my code that's been in production for 3 months. Not sure if I should be impressed or depressed."*

- **Cons:**
  - **New Kid Problems:** As one memorable tweet put it: *"Drizzle looks amazing until you need that ONE feature Prisma has had for years. Then you're writing a plugin at 2am on a Tuesday while questioning your life choices."*
  
  - **Documentation That Assumes You're Already Friends:** Half the time I'm looking for basic examples, not philosophical treatises on database abstraction. The docs often feel like walking into a conversation that's already halfway finished.
  
  - **The Community Size Reality:** When Prisma breaks, 50 people have already asked about it on Stack Overflow. When Drizzle breaks, you're pioneering new error message territory like Lewis and Clark.

### TypeORM: The Ex Who Still Shows Up at Parties

- **Pros:**
  - **It's Everywhere:** Like that one friend who somehow knows everyone, TypeORM is in so many projects that it's impossible to ignore. The "devil you know" factor is strong here.
  
  - **Decorator Syntax That's Familiar:** If you've used Java/C# ORMs, the decorator pattern feels familiar. There's comfort in recognition.
  
  - **Framework Agnostic:** Works with any TypeScript project, which is nice when you're hopping between frameworks faster than a caffeinated rabbit.

- **Cons:**
  - **Documentation From The Twilight Zone:** Finding the right way to do anything is like solving a puzzle where half the pieces are in a different box. A GitHub issue literally titled *"Documentation is like trying to learn Spanish by reading French"* has 200+ upvotes.
  
  - **Migration System That Makes Me Question Reality:** I've had more predictable experiences with the weather than running TypeORM migrations. One memorable Reddit thread: *"My TypeORM migration dropped a production table and now I'm updating my resume."*
  
  - **Active Record AND Data Mapper Patterns:** Can't decide which pattern to use? TypeORM said "why not both?" and created twice the confusion. It's like a restaurant serving both Italian and Chinese food—suspicious from the start.

### Sequelize: Your Dad's ORM

- **Pros:**
  - **It's Battle-Tested:** Like a Nokia phone from 2005, it might not be pretty but it'll survive the apocalypse. Some of the biggest Node.js apps still run Sequelize without issues.
  
  - **Comprehensive Query API:** You can do pretty much anything with Sequelize's API. The question is whether you'll remember how.
  
  - **Hooks System That's Actually Useful:** The before/after hooks are genuinely convenient for things like password hashing and audit logging.

- **Cons:**
  - **Verbose Like A Victorian Novel:** Prepare to type until your fingers bleed. This actual code example is not a joke:
  
  ```javascript
  const { Op } = require("sequelize");
  await User.findAll({
    where: {
      [Op.and]: [
        { status: 'active' },
        {
          [Op.or]: [
            { role: 'admin' },
            { role: 'moderator' }
          ]
        }
      ]
    }
  });
  ```
  
  versus Prisma's:
  
  ```typescript
  await prisma.user.findMany({
    where: {
      status: 'active',
      OR: [
        { role: 'admin' },
        { role: 'moderator' }
      ]
    }
  });
  ```
  
  - **TypeScript Support As An Afterthought:** Using Sequelize with TypeScript feels like retrofitting a car from the 70s with a modern sound system. It works, but you can tell it wasn't designed that way.
  
  - **API Inconsistencies:** Methods like `findOne`, `findAll`, `findAndCountAll` take slightly different parameters in ways that will drive you to drink. Why is it `include` in some places and `includes` in others? Nobody knows!

### Knex: Just Write SQL Already, But Make It JS

- **Pros:**
  - **Query Builder Without The Fluff:** It does one thing—SQL query building—and does it well. No magic, no surprises.
  
  - **Excellent Migration System:** One of the best parts of Knex is its migration tools. Clear, predictable, and straightforward.
  
  - **Lightweight:** It won't add 50MB to your Lambda function, which is nice.

- **Cons:**
  - **No Schema Management:** Hope you like defining your schema in both your database and your code! Double the maintenance, double the fun!
  
  - **No Relations Handling:** Want to fetch a user with their posts and comments? That's several manual queries or some custom code, pal. A Twitter rant I saved: *"Knex is great until you need to fetch related records, then it's DIY hour at the database factory."*
  
  - **Type Safety? What's That?:** You're mostly on your own for types. There are community plugins, but nothing as seamless as Prisma's generated client.

### Mongoose: The MongoDB Wrangler

- **Pros:**
  - **Schema In A Schemaless World:** The irony isn't lost on me, but having a schema for your MongoDB data is actually pretty nice.
  
  - **Middleware That's Actually Useful:** The pre/post hooks are great for things like password hashing and validation.
  
  - **Massive Community:** Any problem you're having has been solved by someone else already. Stack Overflow is full of Mongoose answers.

- **Cons:**
  - **MongoDB:** Listen, I'm not saying MongoDB is bad for every use case, but there's a reason "MongoDB is web scale" is a meme. A classic HackerNews comment: *"We moved from MongoDB to Postgres and our system went from 'sometimes works' to 'always works'."*
  
  - **The Query API Is... Something:** It's powerful, but the syntax is its own special language. `{ $in: [...] }` anyone? It's SQL, Jim, but not as we know it.
  
  - **Performance Cliffs:** Things work great until they don't. That collection with 10,000 documents performs fine until it hits 100,000 and then your server catches fire. Real tweet: *"Our MongoDB queries went from 5ms to 5s overnight. Turns out we crossed some invisible performance threshold."*

### Raw SQL: The Purist's Choice

- **Pros:**
  - **Complete Control:** Nothing between you and your database. You are the captain now.
  
  - **No Dependencies:** One less thing to break or go out of fashion. SQL has been around since the 70s and it'll outlive us all.
  
  - **Performance:** As fast as it gets. Every ORM adds some overhead, no matter how small.

- **Cons:**
  - **Manual Everything:** Hope you like writing `JOIN` statements by hand and updating them every time your schema changes. A Reddit comment that hit home: *"I switched to raw SQL for 'performance reasons' and spent the next 6 months fixing broken queries every time we changed the schema."*
  
  - **Type Safety? LOL:** Enjoy casting your result sets manually and hoping you remembered the column types correctly. Was that an INTEGER or a BIGINT? Surprise!
  
  - **Migration Management:** Roll your own or use a separate tool. Either way, it's more work than using an integrated solution.

---

## Why I Stick With Prisma Despite the Alternatives

At the end of the day, I want to build cool shit without fighting my tools. Prisma hits the sweet spot for me:

1. **It models the world the way I think about it:** People, products, orders—not tables, rows, and foreign keys. The schema definition language is so clear that even non-technical teammates can understand it.

2. **It's fast enough:** For 99% of projects, the performance is more than adequate. And when it's not, Prisma now has the read replicas feature and raw SQL escape hatches.

3. **The schema is the single source of truth:** I define my model once, and everything flows from there. No duplication between code and database. When I change something, I change it in one place.

4. **The ecosystem is mature:** From Prisma Studio to the VS Code extension, the tooling makes my life easier. Real talk: being able to visually inspect my data with Prisma Studio has saved me hours of writing debug queries.

5. **Great error messages:** This might seem minor, but Prisma's error messages actually tell you what went wrong and how to fix it. Compare that to the cryptic nonsense most database libraries throw at you.

An actual conversation from a Discord server I'm in:

> **DevDude123:** Just spent 5 hours debugging a Sequelize query that kept throwing weird errors. Switched to Prisma, got it working in 15 minutes.
> 
> **SQLWhisperer:** But Prisma adds like 5ms overhead!
> 
> **DevDude123:** Cool, I'll take the 5ms hit and get back the 4 hours and 45 minutes of my life.

Could I use Drizzle? Sure. Would TypeORM get the job done? Probably. But Prisma lets me focus on what matters—building features that users care about, not obsessing over the perfect database abstraction.

---

## Conclusion: Use What Makes You Productive

Programming is already hard enough without adding unnecessary complexity. I use Prisma because it makes me productive, not because it's the "best" ORM by some arbitrary metric that only matters in benchmarks.

If you're building the next Twitter or working at the edge with serverless functions where every MB counts, then yeah, maybe explore Drizzle or raw SQL. If you're on a team with deep MongoDB expertise, stick with Mongoose.

But if you want to ship features and not think too hard about your database layer, Prisma is still the best bet in 2025. It's the ORM for people who have shit to do.

### Resources That Actually Helped Me

- [SQL Murder Mystery](https://mystery.knightlab.com/) - Learn SQL by solving a murder. More fun than it has any right to be.
- [Prisma Data Guide](https://www.prisma.io/dataguide) - Actually useful database concepts, not just Prisma propaganda.
- [Database Schema Design Tool](https://dbdiagram.io/) - Visual schema design that doesn't suck.
- [Things I Wish I Knew About SQL](https://dataschool.com/sql-optimization/) - Because there's always more to learn.

---

*Disclaimer: These are my opinions, formed after years of shipping products that people actually use. If you disagree, that's fine—we can still be friends. Unless you think MongoDB is a good choice for financial data, in which case we need to have a serious talk.*